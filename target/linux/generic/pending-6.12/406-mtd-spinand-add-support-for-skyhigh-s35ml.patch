From: KR Kim <kr.kim@skyhighmemory.com>
Date: Fri, 26 Apr 2024 16:20:33 +0900
Subject: [PATCH] mtd: spinand: add support for SkyHigh S35ML flashes

Add support for SkyHigh Memory S35ML01G301, S35ML01G300, S35ML02G300, and
S35ML04G300 SPI NAND flash devices with "Always ECC On" feature and custom
ECC status mapping.

The on-die ECC feature is totally transparent to the host. The ECC parity
bits used for this feature do not occupy the NAND spare areas. The host is
free to have its own ECC engine by using the spare areas that have standard
size.

This patch enables users who have limited ECC capabilities on the host side
to use the NAND flash.

Signed-off-by: KR Kim <kr.kim@skyhighmemory.com>
Co-authored-by: Takahiro Kuwano <takahiro.kuwano@infineon.com>
---
diff --git a/drivers/mtd/nand/spi/Makefile b/drivers/mtd/nand/spi/Makefile
index f725f0c67..7fb8e2130 100644
--- a/drivers/mtd/nand/spi/Makefile
+++ b/drivers/mtd/nand/spi/Makefile
@@ -1,3 +1,3 @@
 # SPDX-License-Identifier: GPL-2.0
 spinand-objs := core.o alliancememory.o ato.o esmt.o fmsh.o foresee.o gigadevice.o macronix.o
-spinand-objs += micron.o paragon.o toshiba.o winbond.o xtx.o
+spinand-objs += micron.o paragon.o skyhigh.o toshiba.o winbond.o xtx.o
diff --git a/drivers/mtd/nand/spi/core.c b/drivers/mtd/nand/spi/core.c
index 8e56ca65a..d4ae63ea9 100644
--- a/drivers/mtd/nand/spi/core.c
+++ b/drivers/mtd/nand/spi/core.c
@@ -196,6 +196,21 @@ static int spinand_init_quad_enable(struct spinand_device *spinand)
 static int spinand_ecc_enable(struct spinand_device *spinand,
 			      bool enable)
 {
+	/*
+	 * SkyHigh Memory: always ECC on
+	 *
+	 * The on-die ECC feature is totally transparent to the host.
+	 * The ECC parity bits used for this feature do not occupy the
+	 * NAND spare areas. The host is free to have its own ECC engine
+	 * by using the spare areas that have standard size.
+	 *
+	 * This allows users who have limited ECC capabilities on the host
+	 * side to still use the NAND flash. This behaviour has been tested
+	 * thoroughly on Linux.
+	 */
+	if (spinand->flags & SPINAND_ON_DIE_ECC_MANDATORY)
+		return 0;
+
 	return spinand_upd_cfg(spinand, CFG_ECC_ENABLE,
 			       enable ? CFG_ECC_ENABLE : 0);
 }
@@ -604,10 +619,11 @@ static int spinand_reset_op(struct spinand_device *spinand)
 			    NULL);
 }
 
-static int spinand_lock_block(struct spinand_device *spinand, u8 lock)
+int spinand_lock_block(struct spinand_device *spinand, u8 lock)
 {
 	return spinand_write_reg_op(spinand, REG_BLOCK_LOCK, lock);
 }
+EXPORT_SYMBOL_GPL(spinand_lock_block);
 
 static int spinand_read_page(struct spinand_device *spinand,
 			     const struct nand_page_io_req *req)
@@ -1166,6 +1182,7 @@ static const struct spinand_manufacturer *spinand_manufacturers[] = {
 	&macronix_spinand_manufacturer,
 	&micron_spinand_manufacturer,
 	&paragon_spinand_manufacturer,
+	&skyhigh_spinand_manufacturer,
 	&toshiba_spinand_manufacturer,
 	&winbond_spinand_manufacturer,
 	&xtx_spinand_manufacturer,
diff --git a/drivers/mtd/nand/spi/skyhigh.c b/drivers/mtd/nand/spi/skyhigh.c
new file mode 100644
index 000000000..d96004ee1
--- /dev/null
+++ b/drivers/mtd/nand/spi/skyhigh.c
@@ -0,0 +1,150 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2024 SkyHigh Memory Limited
+ *
+ * Author: Takahiro Kuwano <takahiro.kuwano@infineon.com>
+ * Co-Author: KR Kim <kr.kim@skyhighmemory.com>
+ */
+
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/mtd/spinand.h>
+
+#define SPINAND_MFR_SKYHIGH			0x01
+#define SKYHIGH_STATUS_ECC_1TO2_BITFLIPS	(1 << 4)
+#define SKYHIGH_STATUS_ECC_3TO6_BITFLIPS	(2 << 4)
+#define SKYHIGH_STATUS_ECC_UNCOR_ERROR		(3 << 4)
+#define SKYHIGH_CONFIG_PROTECT_EN		BIT(1)
+
+static SPINAND_OP_VARIANTS(read_cache_variants,
+		SPINAND_PAGE_READ_FROM_CACHE_QUADIO_OP(0, 4, NULL, 0),
+		SPINAND_PAGE_READ_FROM_CACHE_X4_OP(0, 1, NULL, 0),
+		SPINAND_PAGE_READ_FROM_CACHE_DUALIO_OP(0, 2, NULL, 0),
+		SPINAND_PAGE_READ_FROM_CACHE_X2_OP(0, 1, NULL, 0),
+		SPINAND_PAGE_READ_FROM_CACHE_OP(true, 0, 1, NULL, 0),
+		SPINAND_PAGE_READ_FROM_CACHE_OP(false, 0, 1, NULL, 0));
+
+static SPINAND_OP_VARIANTS(write_cache_variants,
+		SPINAND_PROG_LOAD_X4(true, 0, NULL, 0),
+		SPINAND_PROG_LOAD(true, 0, NULL, 0));
+
+static SPINAND_OP_VARIANTS(update_cache_variants,
+		SPINAND_PROG_LOAD_X4(false, 0, NULL, 0),
+		SPINAND_PROG_LOAD(false, 0, NULL, 0));
+
+static int skyhigh_spinand_ooblayout_ecc(struct mtd_info *mtd, int section,
+					 struct mtd_oob_region *region)
+{
+	if (section)
+		return -ERANGE;
+
+	/* SkyHigh's ECC parity is stored in the internal hidden area */
+	region->length = 0;
+	region->offset = mtd->oobsize;
+
+	return 0;
+}
+
+static int skyhigh_spinand_ooblayout_free(struct mtd_info *mtd, int section,
+					  struct mtd_oob_region *region)
+{
+	if (section)
+		return -ERANGE;
+
+	region->length = mtd->oobsize - 2;
+	region->offset = 2;
+
+	return 0;
+}
+
+static const struct mtd_ooblayout_ops skyhigh_spinand_ooblayout = {
+	.ecc = skyhigh_spinand_ooblayout_ecc,
+	.free = skyhigh_spinand_ooblayout_free,
+};
+
+static int skyhigh_spinand_ecc_get_status(struct spinand_device *spinand,
+					  u8 status)
+{
+	switch (status & STATUS_ECC_MASK) {
+	case STATUS_ECC_NO_BITFLIPS:
+		return 0;
+
+	case SKYHIGH_STATUS_ECC_1TO2_BITFLIPS:
+		return 2;
+
+	case SKYHIGH_STATUS_ECC_3TO6_BITFLIPS:
+		return 6;
+
+	case SKYHIGH_STATUS_ECC_UNCOR_ERROR:
+		return -EBADMSG;
+
+	default:
+		return -EINVAL;
+	}
+}
+
+static const struct spinand_info skyhigh_spinand_table[] = {
+	SPINAND_INFO("S35ML01G301",
+			 SPINAND_ID(SPINAND_READID_METHOD_OPCODE_DUMMY, 0x15),
+			 NAND_MEMORG(1, 2048, 64, 64, 1024, 20, 1, 1, 1),
+			 NAND_ECCREQ(6, 32),
+			 SPINAND_INFO_OP_VARIANTS(&read_cache_variants,
+						      &write_cache_variants,
+						      &update_cache_variants),
+			 SPINAND_ON_DIE_ECC_MANDATORY,
+			 SPINAND_ECCINFO(&skyhigh_spinand_ooblayout,
+					 skyhigh_spinand_ecc_get_status)),
+	SPINAND_INFO("S35ML01G300",
+			 SPINAND_ID(SPINAND_READID_METHOD_OPCODE_DUMMY, 0x14),
+			 NAND_MEMORG(1, 2048, 128, 64, 1024, 20, 1, 1, 1),
+			 NAND_ECCREQ(6, 32),
+			 SPINAND_INFO_OP_VARIANTS(&read_cache_variants,
+						      &write_cache_variants,
+						      &update_cache_variants),
+			 SPINAND_ON_DIE_ECC_MANDATORY,
+			 SPINAND_ECCINFO(&skyhigh_spinand_ooblayout,
+					 skyhigh_spinand_ecc_get_status)),
+	SPINAND_INFO("S35ML02G300",
+			 SPINAND_ID(SPINAND_READID_METHOD_OPCODE_DUMMY, 0x25),
+			 NAND_MEMORG(1, 2048, 128, 64, 2048, 40, 2, 1, 1),
+			 NAND_ECCREQ(6, 32),
+			 SPINAND_INFO_OP_VARIANTS(&read_cache_variants,
+						      &write_cache_variants,
+						      &update_cache_variants),
+			 SPINAND_ON_DIE_ECC_MANDATORY,
+			 SPINAND_ECCINFO(&skyhigh_spinand_ooblayout,
+					 skyhigh_spinand_ecc_get_status)),
+	SPINAND_INFO("S35ML04G300",
+			 SPINAND_ID(SPINAND_READID_METHOD_OPCODE_DUMMY, 0x35),
+			 NAND_MEMORG(1, 2048, 128, 64, 4096, 80, 2, 1, 1),
+			 NAND_ECCREQ(6, 32),
+			 SPINAND_INFO_OP_VARIANTS(&read_cache_variants,
+						      &write_cache_variants,
+						      &update_cache_variants),
+			 SPINAND_ON_DIE_ECC_MANDATORY,
+			 SPINAND_ECCINFO(&skyhigh_spinand_ooblayout,
+					 skyhigh_spinand_ecc_get_status)),
+};
+
+static int skyhigh_spinand_init(struct spinand_device *spinand)
+{
+	/*
+	 * Config_Protect_En (bit 1 in Block Lock register) must be set to 1
+	 * before writing other bits. Do it here before core unlocks all blocks
+	 * by writing block protection bits.
+	 */
+	return spinand_lock_block(spinand, SKYHIGH_CONFIG_PROTECT_EN);
+}
+
+static const struct spinand_manufacturer_ops skyhigh_spinand_manuf_ops = {
+	.init = skyhigh_spinand_init,
+};
+
+const struct spinand_manufacturer skyhigh_spinand_manufacturer = {
+	.id = SPINAND_MFR_SKYHIGH,
+	.name = "SkyHigh",
+	.chips = skyhigh_spinand_table,
+	.nchips = ARRAY_SIZE(skyhigh_spinand_table),
+	.ops = &skyhigh_spinand_manuf_ops,
+};
+
diff --git a/include/linux/mtd/spinand.h b/include/linux/mtd/spinand.h
index e5b6ac340..ece5d0c55 100644
--- a/include/linux/mtd/spinand.h
+++ b/include/linux/mtd/spinand.h
@@ -270,6 +270,7 @@ extern const struct spinand_manufacturer gigadevice_spinand_manufacturer;
 extern const struct spinand_manufacturer macronix_spinand_manufacturer;
 extern const struct spinand_manufacturer micron_spinand_manufacturer;
 extern const struct spinand_manufacturer paragon_spinand_manufacturer;
+extern const struct spinand_manufacturer skyhigh_spinand_manufacturer;
 extern const struct spinand_manufacturer toshiba_spinand_manufacturer;
 extern const struct spinand_manufacturer winbond_spinand_manufacturer;
 extern const struct spinand_manufacturer xtx_spinand_manufacturer;
@@ -316,6 +317,7 @@ struct spinand_ecc_info {
 #define SPINAND_HAS_CR_FEAT_BIT		BIT(1)
 #define SPINAND_HAS_PROG_PLANE_SELECT_BIT		BIT(2)
 #define SPINAND_HAS_READ_PLANE_SELECT_BIT		BIT(3)
+#define SPINAND_ON_DIE_ECC_MANDATORY	BIT(4)
 
 /**
  * struct spinand_ondie_ecc_conf - private SPI-NAND on-die ECC engine structure
@@ -539,5 +541,6 @@ int spinand_match_and_init(struct spinand_device *spinand,
 int spinand_upd_cfg(struct spinand_device *spinand, u8 mask, u8 val);
 int spinand_write_reg_op(struct spinand_device *spinand, u8 reg, u8 val);
 int spinand_select_target(struct spinand_device *spinand, unsigned int target);
+int spinand_lock_block(struct spinand_device *spinand, u8 lock);
 
 #endif /* __LINUX_MTD_SPINAND_H */
